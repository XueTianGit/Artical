title: C-const与volatile
date: 2016/3/14 11:06:07    
categories: C
---

# C-const与volatile #

## const ##

>const修饰的变量不是真正的常量
>
> - 1. const用来修饰的变量， 是只读变量， 即还是一个变量， 我们还是可以使用间接方式改变其值
> - 2. const修饰的变量会在内存中占有空间（常量是不会的）
> - 3. 本质上const只对编译器有用，但是在运行时是无用的。
> - 4. const只读变量是不可以直接作为左值的。

例如下面代码，只读变量a的值就已经被改变。

		const int a = 0;
	    int* pa = &a;
	    *pa = 5;


>const可以扩大函数接受参数的范围， 例如:

	int receiveAll(const int a);     //这个a即可接受只读变量， 也可以接收普通变量。 
	int receiveAll(int a);          //这个a只可接收普通变量。  


>当const用来修饰数组时，形式类似于修饰普通变量。
>
>const修饰指针时， 可以使用“左数右指” 来理解

	int* const p = &a;   //p是一个常量指针, 不可以再直接改变其指向
	const int* p = &a;    or  int contst *p;     //p值向的内存是一个只读内存， 不过p的指向可以随意改变
>const修饰函数参数和返回值

	1. const修饰函数参数， 表示在函数体内并不希望改变参数值
	2. const修饰函数返回值表示返回值不可变，  多用于返回指针， 例如：
	const int* func()
	{
		static int count =  0;
		count++;
		return &count;  //不能返回局部变量的地址！！！！ 
	}
	//如果这样做就是错的：  int* p = func();  //因为你在接下来可能会修改返回只读变量的内容


## volatile ##
这个关键字一般用在定义寄存器变量时。

> - 1. 它可以理解为“编译器警告关键字”， 即去警告编译器不要去做优化
> - 2. 它告诉编译器每次必须去内存中取变量的值
> - 3. 它组要用来修饰可能被多个线程访问的变量或者可能被未知因素改变的变量（寄存器）



	 


