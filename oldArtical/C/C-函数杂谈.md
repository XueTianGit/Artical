title: C-函数杂谈
date: 2016/3/14 11:11:14      
categories: C
---

# C-函数杂谈 #

- 函数的由来
> - 程序 = 数据 + 算法 
> - C程序 = 数据 + 函数
> - C语言推动了模块化程序设计的产生 

- 面向过程的程序设计(模块化)   ->  核心： 函数
>- 面向过程是一种以过程为中心的编程思想
>- 首先将复杂的问题分解为一个个容易解决的问题
>- 分解后的问题可以按步骤一步步解决
>- 函数是面向过程在C语言的实现
>- 解决问题的每个步骤可以用函数事项

- 函数参数
> - 函数参数在本质上与局部变量相同，都是在栈上分配空间
> - 函数参数的初始化值是实参的值
> - 函数参数的求值顺序是不固定的，依赖于编译器的实现（顺序点）
> - C语言默认没有类型的函数参数类型为int（函数的缺省认定）
> - 函数参数的计算顺序，依赖于编译器的实现（调用约定）

即这段代码并不会报错：

	int func()
	{
		printf("Hello World!");
	}
	int main()
	{
			
		func(5);
		return 0;
	}

- 可变参数列表
>- C语言可以定义可变参数列表
>- 参数可变函数的实现依赖于stdarg.h头文件
>- va_list变量与va_start, va_end和va_arg配合使用能够访问参数值， 他们都是宏实现

使用示例：

	/*
		这个函数可以用来求n个int值得平均数 
	*/
	float average(int n, ...)
	{
		va_list args;  //代表接收的可变参数列表
		int i = 0;
		float sum = 0;
		
		va_start(args, n); //初始化列表
		for(i=0; i<n; i++)
		{
			sum += va_arg(args, int);	
		}
		
		va_end(args);
		
		return sum / n;
		
	}
	
	
	int main()
	{
			
		printf("the average is %0.2f \n", average(4, 1, 2, 3, 4));
		
		return 0;
	}

- C语言可变参数的限制
>- 可变参数必须从头到尾按照顺序逐个访问
>- 参数列表中至少存在一个确定的命令参数（用于指示参数的个数）
>- 可变参数宏无法判断实际存在的参数的数量（靠你自己）
>- 可变参数无法判断参数的实际类型

- 函数与宏
>- 宏是由预处理器直接替换展开的， 编译器不知道有宏的存在
>- 函数是有编译器直接编译的实体，调用行为由编译器决定
>- 多次调用宏会导致程序代码的增加，函数是跳转执行，并不会导致这个问题
>- 宏的效率要比函数高，他并没有调用开销
>- 函数调用会创建活动记录，相比于宏效率较低
>- 宏如果处理不当，往往会出现意想不到的问题
>- 但是
>- 函数和宏并不是竞争对手，设计程序时，我们应怎么顺手怎么写！

看下面这个， 

	#define _MUL(a, b) ((a) < (b) ? (a) : (b))
	int main()
	{
		int i = 9;
		printf("The result is  -> %d \n", _MUL(i++, 10));
		
		return 0;
	}

- 宏的无可替代的优势
>- 宏的参数可以是任何C语言类型， 可以是类型名！

示例：	

	// #define Malloc(type, n) (type*)malloc(sizeof(type) * n)

- 活动记录： 函数调用时用于记录一系列相关信息的记录（建立在栈上）
>- 临时变量域：用来存放临时变量的值， 如k++的中间结果
>- 局部变量域：用来存放函数本次执行中的局部变量
>- 机器状态域：用来保存调用函数之前有关的机器状态信息，包括各种寄存器的当前值，和返回地址
>- 实参数域：  用于存放函数的实参信息
>- 返回值域：  为调用函数存放返回值


- 调用约定
>- 当一个函数被调用时，参数会传递给被滴啊用的函数，而返回值会被返回给调用函数。
>- 而函数调用约定就是描述参数是怎么传递到栈空间的，以及栈空间由谁来维护
>- 调用约定是调用者和被调用者之间的调用协议， 常用于不同开发者编写的库函数之间
>- 当两个调用约定不同的调用者，调用一个依赖于调用约定的函数时， 函数可能会发生错误女
	- 参数传递顺序（的一些约定）
		- 从右到左依次入栈： _stdcall, _cdecl， _thiscall
		- 从左到右依次入栈： _pascal, _fastcall
	- 调用堆栈的清理工作
		- 被调用者自己清楚
		- 调用者负者清除

- C函数设计技巧
	- 不要在函数中使用全局变量，尽量让函数从意义上是一个独立的模块， 不受其他影响
	- 如果参数是指针，且仅做输入参数用， 则应在类型前面加上const， 以防止指针被以外修改
	- 不要省略返回值类型，函数没用返回值就声明为void（C函数默认返回int）
	- 在函数的入口处，要对参数的有效性进行检查， 尤其是指针参数
	- 在函数中不要返回指向栈空间的指针！
	- 函数的规模控制在80行以内
	- 尽量避免函数带有记忆性功能(static)， 即相同输入，要有相同的输出
	- 函数参数应控制在4个以内
	- 函数的返回值可以使函数支持链式表达式。



The END！
