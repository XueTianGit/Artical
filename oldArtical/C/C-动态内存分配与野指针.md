title: C-动态内存分配与野指针
date: 2016/3/14 11:10:01      
categories: C
---

# C-动态内存分配与野指针 #

## 动态内存分配 ##
	
- 为什么需要动态内存分配
	- C语言中的一切操作都是基于内存的
	- 变量和数组都是内存的别名，如何分配这些内存由编译器在编译期间决定
		- 比如，定义数组时，必须指定数组的长度，而数组的长度是在编译器就决定的
	- 当时，当我们的程序运行是，我们可能会需要一些额外的内存空间

- malloc，calloc和realloc
	- malloc所分配的是一块连续的内存，以字节为单位，并不带任何类型
		- malloc的分配的内存来自于堆， 由于操作系统对内存的管理策略问题， 我们在利用malloc请求内存时，系统分配的内存可能会多一些
		- 当请求动态内存无法满足时，malloc会返回NULL
	- calloc和realloc是malloc的兄弟， 他们都是基于malloc实现的
		- calloc: void* calloc(size_t num, size_t size)   //内存大小为 num * size
			- calloc的参数代表返回内存的类型信息
			- calloc会将返回的内存初始化为0
		- recalloc： void* realloc(void* pointer, size_t newSize)  //即将pointer指向的内存空间大小重置为newSize 
			- 它用于修改一个已经分配的内存块的大小
			- 在使用realloc之后，我们应使用他的返回值，而不是使用原来的指针
			- 当pointer的第一个参数为NULL时，他就等价于malloc

- free
	- free用于将动态内存归还给系统
	- 当free的参数为NULL时，函数直接返回


## 野指针 ##

- 基本点
	- 牵扯的动态内存分配，野指针就会跟着来了。
	- 野指针是指指针变量中保存的值并不是一个合法的内存地址，使用野指针访问这个内存，会出现问题
	- 野指针不是NULL指针，是指向不可用内存的指针
	- NULL指针不可怕，他是我们解决野指针带来的问题关键
	- 在C语言中没有任何手段可以判断一个内存是否为野指针

- 野指针的由来
	- 局部指针变量没有被初始化
	- 使用已经释放过的指针
	- 指针所指向的变量在指针之前被销毁

- 如何避免野指针
	- 使用malloc申请内存之后，应该立即检查指针值是否为NULL，防止使用的值为NULL的指针
	- 牢记数组长度，防止数组的越界操作，考虑使用柔性数组
	- 动态申请操作必须和释放操作匹配，防止内存泄露和多次释放
	- free指针之后应把指针立即赋值为NULL


可以参考的编码规范：
	int main()
	{
	
		int* p = (int*)malloc(5 * sizeof(int)); 
		if(p != NULL)
		{
			/*.....*/			
		}
		
		free(p);
		p = NULL;  //p指向的并不是原来的内存， 系统已经把它指向的内存回收了，可能用于别处了 
		
		
		
		return 0;
	}
		

	